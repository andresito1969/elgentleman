# This is useFetch custom hook sample

```
  import { useEffect, useState } from "react";
  
  type Data<T> = T | null;
  type ErrorType = Error | null;

  interface Params<T> {
    data: Data<T>;
    loading: boolean;
    error: ErrorType;
  }

    export const useFetch = <T>(url: string): Params<T> {
      const [data, setData] = useState<Data<T>>(null)
      const [loading, setLoading] = useState(true)
      const [error, setError] = useState<ErrorType>(null)

      useEffect(() => 
        const controller = new AbortController()
        const fetchData = async () => {
          try {
            const response = await fetch(url, controller);

            if (!response.ok) throw new Error("error en la peticiÃ³n")

            const jsonData: T = await response.json()
            setData(jsonData)
          } catch(err) {
            setError(err as Error)
          } finally {
            setLoading(false)
          }

          return () => {
            controller.abort()
          }
        }

        fetchData()
      }, [url])

      return { data, loading, error }
    }

```


## Lo usamos en un componente....

import {useFetch} from 'customhooks'

const url = "...."

interface Data {
  name: string;
  lastName: string;
  age: number;
}

const App = () => {
  const {data, error, loading} = useFetch<Data>(url)

  // Ahora el data tiene type Data gracias al generic

  ....
}
